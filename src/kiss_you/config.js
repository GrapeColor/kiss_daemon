import path from 'path';
import fs from 'fs';
import { EventEmitter } from 'events';

const defaultFile
  = fs.readFileSync(path.resolve('src/kiss_you/assets/default_config.json'), 'utf-8');

import fetch from 'isomorphic-fetch';
import pkgDropbox from 'dropbox';
const { Dropbox } = pkgDropbox;

const dropbox = new Dropbox({ accessToken: process.env['DROPBOX_TOKEN'], fetch: fetch });

import Discord from 'discord.js';

import twemojiRegex from 'twemoji-parser/dist/lib/regex.js';
const emojiRegex
  = new RegExp(`^${twemojiRegex.default.toString().slice(1, -9)}$|^<a?:\\w+:(\\d+)>$`);

/**
 * @typedef {Object} ConfigProperty
 * @property {string} guildID
 * @property {string[]} adminRoles
 * @property {LiveChannelProperty} liveChannel
 */

/**
 * @typedef {Object} LiveChannelProperty
 * @property {string} acceptChannel
 * @property {string[]} allowRoles
 * @property {string[]} restricRoles
 * @property {string} liveName
 * @property {string} closeEmoji
 * @property {string} defaultTopic
 * @property {number} minLive
 * @property {number} maxLive
 * @property {number} maxOpenLive
 * @property {number} autoClose
 * @property {number} defaultRateLimit
 * @property {boolean} onlySelf
 * @property {boolean} liveBadge
 * @property {boolean} pinLink
 * @property {boolean} autoDelete
 * @property {boolean} defaultNSFW
 */

export default class Config extends EventEmitter {
  /**
   * Configs for all guilds.
   * @type {Object.<string, Config>}
   */
  static configs = {}

  /**
   * Default config.
   * @type {ConfigProperty}
   */
  static defaultConfigJSON = Object.freeze(JSON.parse(defaultFile));

  /**
   * Load configs for all guilds.
   */
  static async load() {
    const fileList = await dropbox.filesListFolder({ path: '' });

    for (const metadata of fileList.entries) {
      if (metadata[".tag"] !== 'file') continue;

      const fileMetadata = await dropbox.filesDownload({ path: metadata.path_lower });
      const file = fileMetadata.fileBinary?.toString('utf-8');
      const matchID = fileMetadata.path_lower.match(/\/(\d+)\.json/);

      if (!file || !matchID) continue;

      const guildID = matchID[1];
      this.configs[guildID] = new Config(guildID, JSON.parse(file));
    }
  }

  /**
   * Read guild config.
   * @param {string} guildID - Guild ID.
   */
  static read(guildID) {
    if (!this.configs[guildID])
      this.configs[guildID] = new Config(guildID, this.defaultConfigJSON);

    return this.configs[guildID];
  }

  /**
   * Events to enter the client.
   * @param {Discord.Client} bot Discord.js Client.
   */
  static events(bot) {
    bot.on('ready', () => {
      this.botMention = bot.user.toString();
      this.botMentionRegex = new RegExp(`^<@!?${bot.user.id}>`);
    });

    bot.on('message', message => {
      const channel = message.channel;

      if (channel.type !== 'text' || message.author.bot) return;

      if (this.botMentionRegex.test(message.content))
        this.parseCommand(channel, message)
          .catch(console.error);
    });
  }

  /**
   * Parse commands.
   * @param {Discord.TextChannel} channel - Guils's text channel.
   * @param {Discord.Message} message - Event trigger message.
   */
  static async parseCommand(channel, message) {
    const guild = channel.guild;
    const adminRoles = Config.read(guild.id).adminRoles;

    const member = channel.guild.members.resolve(message.author);
    const roles = member.roles.cache.filter(role => adminRoles.includes(role.id));

    if (!member.hasPermission('ADMINISTRATOR') && !roles.size) return;

    this.configs[guild.id].command(channel, message)
      .catch(console.error);
  }

  /**
   * Initialize the guild config.
   * @param {string} guildID - Guild ID.
   * @param {ConfigProperty} json - The config json data.
   */
  constructor(guildID, json) {
    super();

    this.guildID = guildID;
    this.adminRoles = json.adminRoles;
    this.liveChannel = json.liveChannel;
  }

  /**
   * Execute command.
   * @param {Discord.TextChannel} channel - Guils's text channel.
   * @param {Discord.Message} message - Event trigger message.
   */
  async command(channel, message) {
    const args = message.content.split(' ').slice(1);

    if (!args[0]) this.sendValues(channel);

    switch(args[0]) {
      case 'admin':
        if (args[1] === 'add')
          await this.setAdminRoles(channel, channel.guild, args.slice(2), true);
        if (args[1] === 'remove')
          await this.setAdminRoles(channel, channel.guild, args.slice(2), false);
      case 'live':
        this.commandLive(channel, args.slice(1));
        break;
    }
  }

  /**
   * Send command help.
   * @param {Discord.TextChannel} channel - Guils's text channel.
   */
  sendValues(channel) {
    const embed = new Discord.MessageEmbed;

    embed.color = 0x1587bf;
    embed.title = 'üá∂ Ë®≠ÂÆöÂÄ§‰∏ÄË¶ß';
    embed.description = 'ÂêÑË®≠ÂÆö„ÅÆÂ§âÊõ¥ÊñπÊ≥ï„ÅØ[„Éâ„Ç≠„É•„É°„É≥„Éà]()„Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ';

    embed.addFields([
      {
        name: 'ÁÆ°ÁêÜËÄÖ„É≠„Éº„É´',
        value: this.adminRoles.map(id => `<@&${id}>`).join('\n') || '```„Å™„Åó```'
      },
      {
        name: '===========================================================',
        value: 'üî¥ **ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Ê©üËÉΩ„ÅÆË®≠ÂÆöÂÄ§**'
      },
      {
        name: 'ÂÆüÊ≥ÅÂèó‰ªò„ÉÅ„É£„É≥„Éç„É´',
        value: this.liveChannel.acceptChannel
          ? `<#${this.liveChannel.acceptChannel}>` : '```„Å™„Åó(Ê©üËÉΩÁÑ°Âäπ)```',
        inline: true
      },
      {
        name: 'ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Âêç',
        value: `\`\`\`${this.liveChannel.liveName}\`\`\``,
        inline: true
      },
      {
        name: '„Éá„Éï„Ç©„É´„Éà„Éà„Éî„ÉÉ„ÇØ',
        value: `\`\`\`${this.liveChannel.defaultTopic || '(Êú™Ë®≠ÂÆö)'}\`\`\``
      },
      {
        name: '„Éá„Éï„Ç©„É´„Éà„É¨„Éº„ÉàÂà∂Èôê(Áßí)',
        value: `\`\`\`${this.liveChannel.defaultRateLimit}\`\`\``,
        inline: true
      },
      {
        name: '„Éá„Éï„Ç©„É´„ÉàNSFW',
        value: this.liveChannel.defaultNSFW ? '```ÊúâÂäπ```' : '```ÁÑ°Âäπ```',
        inline: true
      },
      {
        name: 'ÂÆüÊ≥ÅÈñãÂßãÂèØËÉΩ„É≠„Éº„É´',
        value: this.liveChannel.allowRoles.map(id => `<@&${id}>`).join('\n')
          || '```Âà∂Èôê„Å™„Åó```'
      },
      {
        name: 'ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´‰∏ãÈôê',
        value: `\`\`\`${this.liveChannel.minLive}\`\`\``,
        inline: true
      },
      {
        name: 'ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´‰∏äÈôê',
        value: `\`\`\`${this.liveChannel.maxLive}\`\`\``,
        inline: true
      },
      {
        name: '1‰∫∫„ÅÇ„Åü„Çä„ÅÆÂÆüÊ≥Å‰∏äÈôê',
        value: `\`\`\`${this.liveChannel.maxOpenLive || 'Âà∂Èôê„Å™„Åó'}\`\`\``,
        inline: true
      },
      {
        name: 'ÂÆüÊ≥ÅÁµÇ‰∫Ü„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÁµµÊñáÂ≠ó',
        value: channel.guild.emojis.cache.get(this.liveChannel.closeEmoji)?.toString()
          || this.liveChannel.closeEmoji,
        inline: true
      },
      {
        name: 'ÂÆüÊ≥ÅÁµÇ‰∫Ü„ÇíÊú¨‰∫∫„Å´ÈôêÂÆö',
        value: this.liveChannel.onlySelf ? '```„Åô„Çã```' : '```„Åó„Å™„ÅÑ```',
        inline: true
      },
      {
        name: 'ÂÆüÊ≥ÅÁµÇ‰∫ÜÂæå„ÅÆÁô∫Ë®ÄÁÑ°Âäπ„É≠„Éº„É´',
        value: this.liveChannel.restricRoles.map(id => `<@&${id}>`).join('\n')
          || '```„Å™„Åó```'
      },
      {
        name: 'ÂÆüÊ≥ÅËá™ÂãïÁµÇ‰∫ÜÊôÇÈñì(ÂàÜ)',
        value: `\`\`\`${this.liveChannel.autoClose || '„Å™„Åó(Ê©üËÉΩÁÑ°Âäπ)'}\`\`\``,
        inline: true
      },
      {
        name: 'ÂÆüÊ≥Å‰∏≠„Éê„ÉÉ„Ç∏Ë°®Á§∫',
        value: this.liveChannel.liveBadge ? '```„Åô„Çã```' : '```„Åó„Å™„ÅÑ```',
        inline: true
      },
      {
        name: 'ÂÆüÊ≥Å„É™„É≥„ÇØ„Éî„É≥Ê≠¢„ÇÅ',
        value: this.liveChannel.pinLink ? '```„Åô„Çã```' : '```„Åó„Å™„ÅÑ```',
        inline: true
      },
      {
        name: 'ÂÆüÊ≥Å„É™„É≥„ÇØËá™ÂãïÂâäÈô§',
        value: this.liveChannel.autoDelete ? '```„Åô„Çã```' : '```„Åó„Å™„ÅÑ```',
        inline: true
      }
    ])

    channel.send('', embed)
      .catch(console.error);
  }

  /**
   * Set admin roles.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {Discord.Guild} guild - Discord guild.
   * @param {string[]} args - Parsed command arguments.
   * @param {boolean} add - add or remove.
   */
  async setAdminRoles(channel, guild, args, add) {
    const roles = this.adminRoles;
    const guildRoles = guild.roles.cache;
    const setRoles = args.map(arg => arg.match(/^((\d+)|<@&(\d+)>)$/))
      .map(arg => arg && (arg[2] || arg[3]))
      .filter(roleID => guildRoles.has(roleID)
        && (add && !roles.includes(roleID) || !add && roles.includes(roleID)));

    if (add) {
      roles.push(...setRoles);
    } else {
      roles = roles.filter(roleID => !setRoles.includes(roleID));
    }

    if (await this.updateConfig(channel, 'adminRoles', null, roles)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ „É≠„Éº„É´„Åå${add ? 'ËøΩÂä†' : 'ÂâäÈô§'}„Åï„Çå„Åæ„Åó„Åü`,
          description: 'Ë®≠ÂÆö„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å„Åß„Åç„Çã„É≠„Éº„É´:\n'
            + this.adminRoles.map(id => `<@&${id}>`).join(' ')
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Change live config.
   * @param {Discord.TextChannel} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async commandLive(channel, args) {
    switch (args[0]) {
      case 'accept':
        if (args[1] === 'set')
          await this.setAccept(channel, channel.guild, args.slice(2), true);
        if (args[1] === 'remove')
          await this.setAccept(channel, channel.guild, args.slice(2), false);
        break;
      case 'allow':
        if (args[1] === 'add')
          await this.setAllowRoles(channel, channel.guild, args.slice(2), true);
        if (args[1] === 'remove')
          await this.setAllowRoles(channel, channel.guild, args.slice(2), false);
        break;
      case 'restric':
        if (args[1] === 'add')
          await this.setRestricRoles(channel, channel.guild, args.slice(2), true);
        if (args[1] === 'remove')
          await this.setRestricRoles(channel, channel.guild, args.slice(2), false);
        break;
      case 'name':
        await this.setLiveName(channel, args.slice(1));
        break;
      case 'close-emoji':
        await this.setCloseEmoji(channel, channel.guild, args.slice(1));
        break;
      case 'default-topic':
        await this.setDefaultTopic(channel, args.slice(1));
        break;
      case 'min':
        await this.setMinLive(channel, args.slice(1));
        break;
      case 'max':
        await this.setMaxLive(channel, args.slice(1));
        break;
      case 'max-open':
        await this.setMaxOpenLive(channel, args.slice(1));
        break;
      case 'auto-close':
        await this.setAutoClose(channel, args.slice(1));
        break;
      case 'default-ratelimit':
        await this.setDefaultRateLimit(channel, args.slice(1));
        break;
      case 'only-self':
        if (args[1] === 'enable')  await this.setOnlySelf(channel, true);
        if (args[1] === 'disable') await this.setOnlySelf(channel, false);
        break;
      case 'badge':
        if (args[1] === 'enable')  await this.setBadge(channel, true);
        if (args[1] === 'disable') await this.setBadge(channel, false);
        break;
      case 'pin-massage':
        if (args[1] === 'enable')  await this.setPinLink(channel, true);
        if (args[1] === 'disable') await this.setPinLink(channel, false);
        break;
      case 'auto-delete':
        if (args[1] === 'enable')  await this.setAutoDelete(channel, true);
        if (args[1] === 'disable') await this.setAutoDelete(channel, false);
        break;
      case 'default-NSFW':
        if (args[1] === 'enable')  await this.setDefaultNSFW(channel, true);
        if (args[1] === 'disable') await this.setDefaultNSFW(channel, false);
    }
  }

  /**
   * Set the channel that accepts live.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {Discord.Guild} guild - Discord guild.
   * @param {string[]} args - Parsed command arguments.
   * @param {boolean} set - Enable or Disable.
   */
  async setAccept(channel, guild, args, set) {
    let acceptID = '';

    if (set) {
      const matchAccept = args[0]?.match(/^((\d+)|<#(\d+)>)$/);
      acceptID = matchAccept && (matchAccept[2] || matchAccept[3]);
      const accept = guild.channels.cache.get(acceptID);
  
      if (!accept || accept.type !== 'text') {
        channel?.send('', {
          embed: {
            color: 0xffcd60,
            title: '‚ö†Ô∏è ÊåáÂÆö„Åó„Åü„ÉÅ„É£„É≥„Éç„É´„ÅåÊúâÂäπ„Å™ÂÄ§„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
            description: '„Çµ„Éº„Éê„ÉºÂÜÖ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÉÅ„É£„É≥„Éç„É´„Çí„ÄÅ„É°„É≥„Ç∑„Éß„É≥ÂΩ¢Âºè„ÅãID„ÅßÊåáÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ'
          }
        })
          .catch(console.error);
  
        return;
      }
    }

    if (await this.updateConfig(channel, 'liveChannel', 'acceptChannel', acceptID)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥ÅÂèó‰ªò„ÉÅ„É£„É≥„Éç„É´„Çí${acceptID ? `Â§âÊõ¥` : 'ÁÑ°Âäπ„Å´'}„Åó„Åæ„Åó„Åü`,
          description: acceptID ? `<#${acceptID}> „ÅßÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÇíÈñãÂßã„Åß„Åç„Åæ„Åô„ÄÇ` : ''
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set roles that are allowed to create live channels.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {Discord.Guild} guild - Discord guild.
   * @param {string[]} args - Parsed command arguments.
   * @param {boolean} add - add or remove.
   */
  async setAllowRoles(channel, guild, args, add) {
    const roles = this.liveChannel.allowRoles;
    const guildRoles = guild.roles.cache;
    const setRoles = args.map(arg => arg.match(/^((\d+)|<@&(\d+)>)$/))
      .map(arg => arg && (arg[2] || arg[3]))
      .filter(roleID => guildRoles.has(roleID)
        && (add && !roles.includes(roleID) || !add && roles.includes(roleID)));

    if (add) {
      roles.push(...setRoles);
    } else {
      roles = roles.filter(roleID => !setRoles.includes(roleID));
    }

    if (await this.updateConfig(channel, 'liveChannel', 'allowRoles', roles)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ „É≠„Éº„É´„Åå${add ? 'ËøΩÂä†' : 'ÂâäÈô§'}„Åï„Çå„Åæ„Åó„Åü`,
          description: 'ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÇíÈñãÂßã„Åß„Åç„Çã„É≠„Éº„É´:\n'
            + this.liveChannel.allowRoles.map(id => `<@&${id}>`).join(' ')
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set roles that are restric messages.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {Discord.Guild} guild - Discord guild.
   * @param {string[]} args - Parsed command arguments.
   * @param {boolean} add - add or remove.
   */
  async setRestricRoles(channel, guild, args, add) {
    const roles = this.liveChannel.restricRoles;
    const guildRoles = guild.roles.cache;
    const setRoles = args.map(arg => arg.match(/^((\d+)|<@&(\d+)>)$/))
      .map(arg => arg && (arg[2] || arg[3]))
      .filter(roleID => guildRoles.has(roleID)
        && (add && !roles.includes(roleID) || !add && roles.includes(roleID)));

    if (add) {
      roles.push(...setRoles);
    } else {
      roles = roles.filter(roleID => !setRoles.includes(roleID));
    }

    if (await this.updateConfig(channel, 'liveChannel', 'restricRoles', roles)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ „É≠„Éº„É´„Åå${add ? 'ËøΩÂä†' : 'ÂâäÈô§'}„Åï„Çå„Åæ„Åó„Åü`,
          description: 'ÁµÇ‰∫Ü„Åó„ÅüÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„Åß„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„ÅåÁÑ°ÂäπÂåñ„Åï„Çå„Çã„É≠„Éº„É´:\n'
            + this.liveChannel.restricRoles.map(id => `<@&${id}>`).join(' ')
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set live channel base name.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setLiveName(channel, args) {
    if (!args[0]) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    if (args[0].length > 90) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Âêç„ÅØ90ÊñáÂ≠ó‰ª•‰∏ã„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    if (await this.updateConfig(channel, 'liveChannel', 'liveName', args[0])) {
      this.emit('liveNameUpdate');

      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: '‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Âêç„ÇíË®≠ÂÆö„Åó„Åæ„Åó„Åü',
          description: `‰ª•Èôç \`${args[0]}ÔΩû\` „ÅåÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„Å®„Åó„Å¶Ë™çË≠ò„Åï„Çå„Åæ„Åô„ÄÇ`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set emoji for close live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {Discord.Guild} guild - Discord guild.
   * @param {string[]} args - Parsed command arguments.
   */
  async setCloseEmoji(channel, guild, args) {
    const matchEmoji = args[0]?.match(emojiRegex);

    if (!matchEmoji) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ÁµµÊñáÂ≠ó„Çí1ÊñáÂ≠ó„Å†„ÅëÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    const emoji = matchEmoji[2] || matchEmoji[0];
    const isGuildEmoji = !!matchEmoji[2];

    if (isGuildEmoji && !guild.emojis.cache.has(emoji)) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è „Çµ„Éº„Éê„ÉºÂÜÖ„Å´Â≠òÂú®„Åó„Å™„ÅÑÁµµÊñáÂ≠ó„Åß„Åô'
        }
      })
        .catch(console.error);

      return;
    }

    if (await this.updateConfig(channel, 'liveChannel', 'closeEmoji', emoji)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: '‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÇíÁµÇ‰∫Ü„Åï„Åõ„ÇãÁµµÊñáÂ≠ó„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü',
          description: `${matchEmoji[0]} „ÅßÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÇíÁµÇ‰∫Ü„Åß„Åç„Åæ„Åô`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set default topic of live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setDefaultTopic(channel, args) {
    const topic = args.join(' ');

    if (topic.length > 900) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è „Éá„Éï„Ç©„É´„Éà„Éà„Éî„ÉÉ„ÇØ„ÅÆÊñáÂ≠óÊï∞„ÅØ900ÊñáÂ≠ó„ÅÑ„Åã„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    if (await this.updateConfig(channel, 'liveChannel', 'defaultTopic', topic)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÅÆ„Éá„Éï„Ç©„É´„Éà„Éà„Éî„ÉÉ„ÇØ„ÇíË®≠ÂÆö„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set minimum number of channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setMinLive(channel, args) {
    if (!/^\d+$/.test(args[0])) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ‰∏ãÈôêÊï∞„ÇíÂçäËßíÊï∞Â≠ó„ÅÆÊ≠£Êï∞„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    const min = Number(args[0]);

    if (await this.updateConfig(channel, 'liveChannel', 'minLive', min)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Êï∞„ÅÆ‰∏ãÈôêÂÄ§„Çí ${min} „Å´Ë®≠ÂÆö„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set maximum number of channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setMaxLive(channel, args) {
    if (!/^\d+$/.test(args[0])) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ‰∏äÈôêÊï∞„ÇíÂçäËßíÊï∞Â≠ó„ÅÆÊ≠£Êï∞„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    const max = Number(args[0]);

    if (await this.updateConfig(channel, 'liveChannel', 'maxLive', max)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´Êï∞„ÅÆ‰∏äÈôêÂÄ§„Çí ${max} „Å´Ë®≠ÂÆö„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set maximum number of user open channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setMaxOpenLive(channel, args) {
    if (!/^\d+$/.test(args[0])) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è ‰∏äÈôêÊï∞„ÇíÂçäËßíÊï∞Â≠ó„ÅÆÊ≠£Êï∞„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
          description: '1‰∫∫„ÅÆ„É¶„Éº„Ç∂„Éº„Åå‰ΩøÁî®„Åß„Åç„ÇãÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÅÆ‰∏äÈôêÊï∞„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n'
            + '`0` ‰ª•‰∏ã„ÅÆÊï∞„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅÊ©üËÉΩ„ÅåÁÑ°Âäπ„Å´„Å™„Çä„Åæ„Åô„ÄÇ'
        }
      })
        .catch(console.error);

      return;
    }

    const max = Number(args[0]);;

    if (await this.updateConfig(channel, 'liveChannel', 'maxOpenLive', max)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ 1‰∫∫„ÅÇ„Åü„Çä„ÅÆÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÅÆ‰∏äÈôêÂÄ§„Çí${max ? ` ${max} „Å´Ë®≠ÂÆö` : 'ÁÑ°Âäπ„Å´'}„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set auto close for live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setAutoClose(channel, args) {
    if (!/^\d+$/.test(args[0])) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è Ë®≠ÂÆöÊôÇÈñì(ÂàÜ)„ÇíÂçäËßíÊï∞Â≠ó„ÅÆÊ≠£Êï∞„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
          description: '`0` ‰ª•‰∏ã„ÅÆÊï∞„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅÊ©üËÉΩ„ÅåÁÑ°Âäπ„Å´„Å™„Çä„Åæ„Åô„ÄÇ'
        }
      })
        .catch(console.error);

      return;
    }

    const limit = Number(args[0]);

    if (await this.updateConfig(channel, 'liveChannel', 'autoClose', limit)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ Ëá™ÂãïÁµÇ‰∫Ü${limit ? `ÊôÇÈñì„Çí ${limit} ÂàÜ„Å´Ë®≠ÂÆö` : 'Ê©üËÉΩ„ÇíÁÑ°Âäπ„Å´'}„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set default rate limit of live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {string[]} args - Parsed command arguments.
   */
  async setDefaultRateLimit(channel, args) {
    if (!/^\d+$/.test(args[0])) {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è Ë®≠ÂÆöÊôÇÈñì(Áßí)„ÇíÂçäËßíÊï∞Â≠ó„ÅÆÊ≠£Êï∞„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
        }
      })
        .catch(console.error);

      return;
    }

    const limit = Number(args[0]);

    if (await this.updateConfig(channel, 'liveChannel', 'defaultRateLimit', limit)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ „Éá„Éï„Ç©„É´„Éà„É¨„Éº„ÉàÂà∂Èôê${limit ? `„Çí ${limit} Áßí„Å´Ë®≠ÂÆö` : '„ÇíÁÑ°Âäπ„Å´'}„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set so that only the person can close the live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {boolean} enable - enable or disable.
   */
  async setOnlySelf(channel, enable) {
    if (await this.updateConfig(channel, 'liveChannel', 'onlySelf', enable)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„ÅÆÁµÇ‰∫Ü„ÇíÊú¨‰∫∫„Å´ÈôêÂÆö„Çí${enable ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}„Å´„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set enable live badge on live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {boolean} enable - enable or disable.
   */
  async setBadge(channel, enable) {
    if (await this.updateConfig(channel, 'liveChannel', 'liveBadge', enable)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å‰∏≠„ÉÅ„É£„É≥„Éç„É´„Å∏„ÅÆ„Éê„ÉÉ„ÉÅË°®Á§∫„Çí${enable ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}„Å´„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set enable pin link in live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {boolean} enable - enable or disable.
   */
  async setPinLink(channel, enable) {
    if (await this.updateConfig(channel, 'liveChannel', 'pinLink', enable)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„ÉÅ„É£„É≥„Éç„É´„Å∏„ÅÆÂÆüÊ≥Å„É™„É≥„ÇØ„Éî„É≥Ê≠¢„ÇÅ„Çí${enable ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}„Å´„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set enable auto delete create live message.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {boolean} enable - enable or disable.
   */
  async setAutoDelete(channel, enable) {
    if (await this.updateConfig(channel, 'liveChannel', 'autoDelete', enable)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ ÂÆüÊ≥Å„É™„É≥„ÇØ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆËá™ÂãïÂâäÈô§„Çí${enable ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}„Å´„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Set enable NSFW in live channel.
   * @param {Discord.TextChannel|null} channel - Guils's text channel.
   * @param {boolean} enable - enable or disable.
   */
  async setDefaultNSFW(channel, enable) {
    if (await this.updateConfig(channel, 'liveChannel', 'defaultNSFW', enable)) {
      channel?.send('', {
        embed: {
          color: 0x67b160,
          title: `‚úÖ „Éá„Éï„Ç©„É´„ÉàNSFW„Çí${enable ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}„Å´„Åó„Åæ„Åó„Åü`
        }
      })
        .catch(console.error);
    }
  }

  /**
   * Upload config to Dropbox.
   * @param {Discord.TextChannel|null} channel Guils's text channel.
   * @param {string} key1 - Overrite config property.
   * @param {string|null} key2 - Overrite config property.
   * @param {any} value - Overriting value.
   */
  async updateConfig(channel, key1, key2, value) {
    let oldValue;

    if (key2) {
      oldValue = this[key1][key2];
      this[key1][key2] = value;
    } else {
      oldValue = this[key1];
      this[key1] = value;
    }

    try {
      await dropbox.filesUpload({
        contents: JSON.stringify(this),
        path: `/${this.guildID}.json`,
        mode: { '.tag': 'overwrite' },
        autorename: false,
        mute: true,
        strict_conflict: false
      });
    } catch {
      channel?.send('', {
        embed: {
          color: 0xffcd60,
          title: '‚ö†Ô∏è Ë®≠ÂÆöÂÄ§„ÅÆÂ§âÊõ¥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
          description: 'Ë®≠ÂÆö„Éá„Éº„Çø„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÁµå„Å£„Å¶„Åã„Çâ„ÄÅÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
        }
      })
        .catch(console.error);

      key2 ? this[key1][key2] = oldValue : this[key1] = oldValue;

      return false;
    }

    return true;
  }
}
